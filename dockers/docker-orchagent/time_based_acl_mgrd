#!/usr/bin/env python3

import time
import signal
from swsscommon import swsscommon
from sonic_py_common.logger import Logger 

"""
A script running as a daemon in swss container. It will do following check in loop
1. Read expiration time from STATE_DB
2. Remove corresponding ACL rule if the expiration expired
"""

SYSLOG_IDENTIFIER = 'time_based_acl_mgrd'

TIME_BASED_ACL_RULE_TABLE = "TIME_BASED_ACL_RULE"
APP_ACL_RULE_TABLE_NAME = "ACL_RULE_TABLE"

dynamic_acl_checker = None

logger = Logger(SYSLOG_IDENTIFIER)
logger.set_min_log_priority_info()

class DynamicACLChecker(object):
    
    """
    Worker for checking time-based ACL rules
    """
    def __init__(self, app_db_connector, config_db_connector, interval_in_second=10):
        self.app_db_connector = app_db_connector
        self.config_db_connector = config_db_connector
        self.interval_in_second = interval_in_second
        self.working = False
        self.app_db = swsscommon.DBConnector("APPL_DB", 0, True)

    
    def get_expired_acl_rules(self):
        """
        Retrieve all expired ACL rules from CONFIG_DB
        @return: A list
        """
        expired_entry_names = []
        timenow = int(time.time())
        try:
            # TIME_BASED_ACL_RULE|TEST1|TIME_BASED_RULE_1
            entry_names = self.config_db_connector.keys(self.config_db_connector.CONFIG_DB, TIME_BASED_ACL_RULE_TABLE + r'|*')
        except ValueError:
            logger.log_info("Return NULL expired entry names due to error from config db")
            return []
        for entry_name in entry_names:
            try:
                expiration_time = int(self.config_db_connector.get(self.config_db_connector.CONFIG_DB, entry_name, "expiration_time"))
                if expiration_time <= timenow:
                    expired_entry_names.append(entry_name)
                    continue
            except ValueError:
                # Treat invalid value as expired, otherwise the rule will never be cleared
                expired_entry_names.append(entry_name)
                continue
        #logger.log_info("Get expired ACL rule entry names: {}".format(expired_entry_names))
        return expired_entry_names


    def remove_expired_acl_entries(self, expired_entry_names):
        """
        Remove expired ACL rules from CONFIG_DB and APPL_DB
        @expired_entry_names: exmaple: ['TIME_BASED_ACL_RULE|TEST1|TIME_BASED_RULE_1']
        @return: None
        """
        for entry_name in expired_entry_names:
            self.config_db_connector.delete(self.config_db_connector.CONFIG_DB, entry_name)
            logger.log_info("Removed time-based ACL rule entry from CONFIG_DB: {}".format(entry_name))

        try:
            app_db_entry_names = self.app_db_connector.keys(self.app_db_connector.APPL_DB, APP_ACL_RULE_TABLE_NAME + r':*:TIME_BASED_RULE_*')
            config_db_entry_names = self.config_db_connector.keys(self.config_db_connector.CONFIG_DB, TIME_BASED_ACL_RULE_TABLE + r'|*')
        except ValueError:
            logger.log_info("Cannot remove any acl entry due to error from config db")
            return

        for app_db_entry_name in app_db_entry_names:
            # ACL_RULE_TABLE:TEST1:TIME_BASED_RULE_1
            v = app_db_entry_name.split(":")
            if len(v) != 3:
                logger.log_error("Invalid ACL_RULE_TABLE name to remove: {}".format(app_db_entry_name))
                continue
            acl_table_name, acl_rule_name = v[1], v[2]
            acl_rule_table_name = acl_table_name + "|" + acl_rule_name
            config_db_entry_name = TIME_BASED_ACL_RULE_TABLE + "|" + acl_rule_table_name
            if config_db_entry_name not in config_db_entry_names:
                try:
                    ps = swsscommon.ProducerStateTable(self.app_db, APP_ACL_RULE_TABLE_NAME)
                    ps._del(acl_table_name + ":" + acl_rule_name)
                    logger.log_info("Removed time-based ACL rule entry from APPL_DB: {}".format(app_db_entry_name))
                except ValueError:
                    # Ignore unexisting rules
                    continue


    def get_new_acl_rules(self):
        '''
        Get new added ACL rules from STATE_DB
        @return: New added ACL rules name, example: TIME_BASED_ACL_RULE:TEST1:TIME_BASED_RULE_1
        '''
        new_entry_names = []
        timenow = int(time.time())
        try:
            config_db_entry_names = self.config_db_connector.keys(self.config_db_connector.CONFIG_DB, TIME_BASED_ACL_RULE_TABLE + r'|*')
            app_db_entry_names = self.app_db_connector.keys(self.app_db_connector.APPL_DB, APP_ACL_RULE_TABLE_NAME + r':*:TIME_BASED_RULE_*')
        except ValueError:
            logger.log_info("Return NULL new entry names because of error from db")
            return []

        for config_db_entry_name in config_db_entry_names:
            v = config_db_entry_name.split("|")
            if len(v) != 3:
                logger.log_error("Invalid ACL_RULE_TABLE name to get: {}".format(config_db_entry_name))
                continue
            acl_table_name, acl_rule_name = v[1], v[2]
            acl_rule_table_name = acl_table_name + ":" + acl_rule_name
            app_db_entry_name = APP_ACL_RULE_TABLE_NAME + ":" + acl_rule_table_name
            if app_db_entry_name not in app_db_entry_names:
                try:
                    expiration_time = int(self.config_db_connector.get(self.config_db_connector.CONFIG_DB, config_db_entry_name, "expiration_time"))
                    creation_time = int(self.config_db_connector.get(self.config_db_connector.CONFIG_DB, config_db_entry_name, "creation_time"))
                except ValueError:
                    # Skip entry with invalid value
                    continue
                if timenow <= expiration_time and timenow >= creation_time:
                    new_entry_names.append(config_db_entry_name)
        #logger.log_info("Get new ACL rule entry names: {}".format(new_entry_names))
        return new_entry_names

    
    def add_new_acl_entries(self, new_entry_names):
        '''
        Add new added ACL rules to APPL_DB
        @new_entry_names: New added ACL rules name from CONFIG_DB, example: TIME_BASED_ACL_RULE|TEST1|TIME_BASED_RULE_1
        @return: None
        '''
        for new_entry_name in new_entry_names:
            v = new_entry_name.split("|")
            if len(v) != 3:
                logger.log_error("Invalid ACL_RULE_TABLE name to add: {}".format(new_entry_name))
                continue
            acl_table_name, acl_rule_name = v[1], v[2]
            acl_rule_table_name = acl_table_name + ":" + acl_rule_name
            try:
                new_entry = self.config_db_connector.get_all(self.config_db_connector.CONFIG_DB, new_entry_name)
                del new_entry['creation_time']
                del new_entry['expiration_time']
                del new_entry['is_dynamic']
                del new_entry['ttl']

                ps = swsscommon.ProducerStateTable(self.app_db, APP_ACL_RULE_TABLE_NAME)
                fvs = swsscommon.FieldValuePairs(list(new_entry.items()))
                ps.set(acl_rule_table_name, fvs)
                logger.log_info("Add time-based ACL RULE to APPL_DB: {}".format(APP_ACL_RULE_TABLE_NAME + ":" + acl_rule_table_name))
                logger.log_info(str(new_entry))
            except ValueError:
                # Ignore unexisting rules
                continue


    def start_working(self):
        """
        Main loop for checking TTL and remove expired ACL rules
        """
        self.working = True
        logger.log_notice("time-based ACL manager starts working")
        while self.working:
            expired_entry_names = self.get_expired_acl_rules()            
            self.remove_expired_acl_entries(expired_entry_names)
            new_entry_names = self.get_new_acl_rules()
            self.add_new_acl_entries(new_entry_names)
            if not self.working:
                logger.log_info("time-based ACL manager quit")
                break
            time.sleep(self.interval_in_second)


    def stop_working(self):
        """
        Stop main loop.
        """
        self.working = False
        logger.log_notice("time-based ACL manager is going to quit")


def sig_term_handler(signal, frame):
    """
    A signal handler to ensure the working is shutdown gracefully
    """
    global dynamic_acl_checker
    if dynamic_acl_checker:
        dynamic_acl_checker.stop_working()


def main():
    signal.signal(signal.SIGTERM, sig_term_handler)

    config_db_connector = swsscommon.SonicV2Connector()
    config_db_connector.connect(config_db_connector.CONFIG_DB)
    app_db_connector = swsscommon.SonicV2Connector()
    app_db_connector.connect(app_db_connector.APPL_DB)
    
    # Start working
    global dynamic_acl_checker
    dynamic_acl_checker = DynamicACLChecker(app_db_connector, config_db_connector)
    dynamic_acl_checker.start_working()
    

if __name__ == "__main__":
    main()

